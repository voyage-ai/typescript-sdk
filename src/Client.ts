// This file was auto-generated by Fern from our API Definition.

import type * as VoyageAI from "./api/index.js";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "./BaseClient.js";
import { mergeHeaders } from "./core/headers.js";
import * as core from "./core/index.js";
import * as environments from "./environments.js";
import { handleNonStatusCodeError } from "./errors/handleNonStatusCodeError.js";
import * as errors from "./errors/index.js";
import * as serializers from "./serialization/index.js";

export declare namespace VoyageAIClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class VoyageAIClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<VoyageAIClient.Options>;

    constructor(options: VoyageAIClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Voyage embedding endpoint receives as input a string (or a list of strings) and other arguments such as the preferred model name, and returns a response containing a list of embeddings.
     *
     * @param {VoyageAI.EmbedRequest} request
     * @param {VoyageAIClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.embed({
     *         input: "input",
     *         model: "model"
     *     })
     */
    public embed(
        request: VoyageAI.EmbedRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): core.HttpResponsePromise<VoyageAI.EmbedResponse> {
        return core.HttpResponsePromise.fromPromise(this.__embed(request, requestOptions));
    }

    private async __embed(
        request: VoyageAI.EmbedRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): Promise<core.WithRawResponse<VoyageAI.EmbedResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VoyageAIEnvironment.Default,
                "embeddings",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.EmbedRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.EmbedResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VoyageAIError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/embeddings");
    }

    /**
     * Voyage reranker endpoint receives as input a query, a list of documents, and other arguments such as the model name, and returns a response containing the reranking results.
     *
     * @param {VoyageAI.RerankRequest} request
     * @param {VoyageAIClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.rerank({
     *         query: "query",
     *         documents: ["documents"],
     *         model: "model"
     *     })
     */
    public rerank(
        request: VoyageAI.RerankRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): core.HttpResponsePromise<VoyageAI.RerankResponse> {
        return core.HttpResponsePromise.fromPromise(this.__rerank(request, requestOptions));
    }

    private async __rerank(
        request: VoyageAI.RerankRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): Promise<core.WithRawResponse<VoyageAI.RerankResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VoyageAIEnvironment.Default,
                "rerank",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.RerankRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.RerankResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VoyageAIError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/rerank");
    }

    /**
     * The Voyage multimodal embedding endpoint returns vector representations for a given list of multimodal inputs consisting of text, images, or an interleaving of both modalities.
     *
     * @param {VoyageAI.MultimodalEmbedRequest} request
     * @param {VoyageAIClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.multimodalEmbed({
     *         inputs: [{}],
     *         model: "model"
     *     })
     */
    public multimodalEmbed(
        request: VoyageAI.MultimodalEmbedRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): core.HttpResponsePromise<VoyageAI.MultimodalEmbedResponse> {
        return core.HttpResponsePromise.fromPromise(this.__multimodalEmbed(request, requestOptions));
    }

    private async __multimodalEmbed(
        request: VoyageAI.MultimodalEmbedRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): Promise<core.WithRawResponse<VoyageAI.MultimodalEmbedResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VoyageAIEnvironment.Default,
                "multimodalembeddings",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.MultimodalEmbedRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.MultimodalEmbedResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VoyageAIError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/multimodalembeddings");
    }

    /**
     * The Voyage contextualized embeddings endpoint receives as input a list of documents (each document is a list of chunks), and returns contextualized embeddings for each chunk. The embeddings capture both the local chunk content and the global document context, making them particularly effective for retrieval tasks where understanding document-level context is important.
     *
     * @param {VoyageAI.ContextualizedEmbedRequest} request
     * @param {VoyageAIClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.contextualizedEmbed({
     *         inputs: [["inputs"]],
     *         model: "model"
     *     })
     */
    public contextualizedEmbed(
        request: VoyageAI.ContextualizedEmbedRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): core.HttpResponsePromise<VoyageAI.ContextualizedEmbedResponse> {
        return core.HttpResponsePromise.fromPromise(this.__contextualizedEmbed(request, requestOptions));
    }

    private async __contextualizedEmbed(
        request: VoyageAI.ContextualizedEmbedRequest,
        requestOptions?: VoyageAIClient.RequestOptions,
    ): Promise<core.WithRawResponse<VoyageAI.ContextualizedEmbedResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VoyageAIEnvironment.Default,
                "contextualizedembeddings",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.ContextualizedEmbedRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ContextualizedEmbedResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VoyageAIError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/contextualizedembeddings");
    }
}
